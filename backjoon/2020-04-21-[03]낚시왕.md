# 삼성 SW 역량 테스트 기출 문제

## [03] 낚시왕

https://www.acmicpc.net/problem/17143

**코드 동작 방식**

1. 열(C) 한칸씩 이동하고 행(R) 1~R-1에서 상어 잡기.
2. 상어 이동
   2-1. 상어 한 마리씩 이동하면서 map에 저장
   2-2  map에 이미 상어 있는 경우에는 이동할 상어와 크기 비교
   - 이미 존재하는 상어가 새로운 상어보다 크기가 작으면 새로운 상어 이동x, 반대이면 새로운 상어가 그 자리 차지

---

```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

struct info {
	int r, c, s, d, z;
};

int R, C, M;
vector<info> shark;
vector<info> map[101][101];
int dr[5] = { 0,-1,1,0,0 };
int dc[5] = { 0,0,0,1,-1 };

int catch_shark(int c_idx)
{
	int size = -1;
	for (int i = 1; i <= R; i++) {
		if ((int)map[i][c_idx].size() == 1) {
			size = map[i][c_idx][0].z;
			map[i][c_idx][0].z = -1;
			map[i][c_idx].pop_back();
			break;
		}
	}
	for (int i = 1; i <= R; i++) {
		for (int j = 1; j <= C; j++) {
			if ((int)map[i][j].size() == 1) {
				shark.push_back(map[i][j][0]);
				map[i][j].pop_back();
			}
		}
	}
	return size;
}
void move_shark() {
	int s_size = shark.size();	
	for (int i = 0; i < s_size; i++) {
		int dir = shark[i].d;
		int speed = shark[i].s;

		shark[i].r = shark[i].r + (speed*dr[dir]) % (R * 2 - 2);
		shark[i].c = shark[i].c + (speed*dc[dir]) % (C * 2 - 2);

		while (shark[i].r < 1 || shark[i].c < 1 || shark[i].r > R || shark[i].c > C){

			if (shark[i].d == 1) {
				shark[i].d = 2;
				shark[i].r = -shark[i].r + 2;
			}
			else if (shark[i].d == 2) {
				shark[i].d = 1;
				shark[i].r = 2 * R - shark[i].r;
			}
			else if (shark[i].d == 3) {
				shark[i].d = 4;
				shark[i].c = 2 * C - shark[i].c;
			}
			else if (shark[i].d == 4) {
				shark[i].d = 3;
				shark[i].c = -shark[i].c + 2;
			}
		}
		
		if (map[shark[i].r][shark[i].c].size() == 1) {
			if (map[shark[i].r][shark[i].c][0].z < shark[i].z) {
				map[shark[i].r][shark[i].c].pop_back();
				map[shark[i].r][shark[i].c].push_back(shark[i]);
			}
		}
		else map[shark[i].r][shark[i].c].push_back(shark[i]);
	}
	shark.clear();
}
int main()
{
	cin >> R >> C >> M;
	for (int i = 0; i < M; i++)
	{
		info now;
		cin >> now.r >> now.c >> now.s >> now.d >> now.z;
		map[now.r][now.c].push_back(now);
	}
	
	int ans = 0;
	for (int i = 1; i <= C; i++) {
		int res = catch_shark(i);
		if (res != -1)ans += res;
		move_shark();
	}

	cout << ans << '\n';

	return 0;
}
```

---

**한 번에 구현하지 못했던 실수**

1. 상어를 이동하는 아이디어를 생각하지 못함
 - 아이디어 
   상어가 원래 자리를 유지하고 자기 자신을 돌아오는 경우를 생각하기
   상어가 최종적으로 이동하는 거리: 총 이동할 거리 % (2 * R - 2), 총 이동할 거리 % (2 * C - 2)